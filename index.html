<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V2 Thermal Writer - Phomemo M02S</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef } = React;

    function ThermalWriter() {
      const [isConnected, setIsConnected] = useState(false);
      const [text, setText] = useState('');
      const [status, setStatus] = useState('Disconnected');
      const [device, setDevice] = useState(null);
      const [characteristic, setCharacteristic] = useState(null);
      const [darkness, setDarkness] = useState('standard');
      const [canvasSize, setCanvasSize] = useState('48x50');
      const [font, setFont] = useState('space-mono');
      const textareaRef = useRef(null);
      const previewCanvasRef = useRef(null);

      const connectToPrinter = async () => {
        try {
          setStatus('Connecting...');
          
          // Request Bluetooth device with the correct service UUID
          const device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: 'M02' }],
            optionalServices: ['0000ff00-0000-1000-8000-00805f9b34fb']
          });

          setDevice(device);
          
          // Add disconnect handler
          device.addEventListener('gattserverdisconnected', () => {
            console.log('Device disconnected');
            setIsConnected(false);
            setStatus('Printer disconnected');
            setCharacteristic(null);
          });

          setStatus('Connecting to GATT server...');
          const server = await device.gatt.connect();
          
          setStatus('Getting service...');
          const service = await server.getPrimaryService('0000ff00-0000-1000-8000-00805f9b34fb');
          
          setStatus('Getting characteristic...');
          const char = await service.getCharacteristic('0000ff02-0000-1000-8000-00805f9b34fb');

          setCharacteristic(char);
          setIsConnected(true);
          setStatus('Connected to ' + device.name);
          
        } catch (error) {
          console.error('Connection failed:', error);
          setStatus('Connection failed: ' + error.message);
          setIsConnected(false);
        }
      };

      const disconnect = () => {
        if (device && device.gatt.connected) {
          device.gatt.disconnect();
        }
        setDevice(null);
        setCharacteristic(null);
        setIsConnected(false);
        setStatus('Disconnected');
      };

      // Packet size for Bluetooth transmission
      const PACKET_SIZE_BYTES = 128;

      // Canvas size presets (width x height in mm, converted to pixels at 8px/mm)
      const CANVAS_SIZES = {
        '48x25': { width: 384, height: 200, label: '48x25mm' },
        '48x50': { width: 384, height: 400, label: '48x50mm' },
        '48x100': { width: 384, height: 800, label: '48x100mm' }
      };

      // Font options
      const FONT_OPTIONS = {
        'space-mono': { family: 'Space Mono', label: 'Space Mono' },
        'jetbrains-mono': { family: 'JetBrains Mono', label: 'JetBrains Mono' },
        'courier': { family: 'Courier New', label: 'Courier' },
        'monospace': { family: 'monospace', label: 'System Mono' },
        'arial': { family: 'Arial', label: 'Arial' },
        'times': { family: 'Times New Roman', label: 'Times' },
        'georgia': { family: 'Georgia', label: 'Georgia' }
      };

      // Darkness levels mapped to heat time values
      const DARKNESS_LEVELS = {
        'light': { value: 80, label: 'Light' },
        'standard': { value: 120, label: 'Standard' },
        'dark': { value: 160, label: 'Dark' }
      };

      // Header data for print session with optional heat settings
      const getHeaderData = (widthBytes, heightBytes) => {
        return new Uint8Array([
          0x1b, 0x40,           // ESC @ - initialize printer
          0x1d, 0x76, 0x30, 0x00, // GS v 0 - raster bit image
          widthBytes & 0xFF, (widthBytes >> 8) & 0xFF,     // width in bytes (little-endian)
          heightBytes & 0xFF, (heightBytes >> 8) & 0xFF    // height in bytes (little-endian)
        ]);
      };

      // Heat settings command (ESC 7)
      const getHeatSettings = (heatTime) => {
        return new Uint8Array([0x1b, 0x37, 7, heatTime, 2]);
      };

      // End data for print session - feed 4 lines for easy tearing
      const END_DATA = new Uint8Array([0x1b, 0x64, 0x04]); // ESC d 4 - print and feed 4 lines

      // Determine if pixel should be printed (1 = black dot, 0 = white/no print)
      const getWhitePixel = (canvas, imageData, x, y) => {
        const idx = (canvas.width * y + x) * 4;
        const red = imageData[idx];
        const green = imageData[idx + 1];
        const blue = imageData[idx + 2];
        // Return 1 for black pixels (print), 0 for white pixels (don't print)
        return red + green + blue > 384 ? 0 : 1;
      };

      // Convert canvas to print data
      const getPrintData = (canvas) => {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        
        // Each 8 pixels in a row is represented by a byte
        const data = new Uint8Array((canvas.width / 8) * canvas.height);
        let offset = 0;
        
        // Loop through image rows
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width / 8; x++) {
            const x8 = x * 8;
            // Convert 8 pixels to 1 byte
            data[offset++] =
              getWhitePixel(canvas, imageData, x8 + 0, y) * 128 +
              getWhitePixel(canvas, imageData, x8 + 1, y) * 64 +
              getWhitePixel(canvas, imageData, x8 + 2, y) * 32 +
              getWhitePixel(canvas, imageData, x8 + 3, y) * 16 +
              getWhitePixel(canvas, imageData, x8 + 4, y) * 8 +
              getWhitePixel(canvas, imageData, x8 + 5, y) * 4 +
              getWhitePixel(canvas, imageData, x8 + 6, y) * 2 +
              getWhitePixel(canvas, imageData, x8 + 7, y);
          }
        }
        
        return data;
      };

      const textToBitmap = (text, size, fontKey) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Get dimensions from selected size
        const { width, height } = CANVAS_SIZES[size];
        
        const fontSize = 24;
        const lineHeight = 32;
        const fontFamily = FONT_OPTIONS[fontKey].family;
        
        canvas.width = width;
        canvas.height = height;
        
        // White background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
        
        // Black text
        ctx.fillStyle = 'black';
        ctx.font = `${fontSize}px "${fontFamily}", monospace`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        // Draw each line with minimal padding (2px instead of 5px to use more width)
        const lines = text.split('\n');
        lines.forEach((line, i) => {
          const y = i * lineHeight + 8;
          // Only draw if within canvas bounds
          if (y < height) {
            ctx.fillText(line, 2, y);
          }
        });
        
        return canvas;
      };

      // Update preview canvas
      const updatePreview = () => {
        if (previewCanvasRef.current) {
          const canvas = textToBitmap(text, canvasSize, font);
          const ctx = previewCanvasRef.current.getContext('2d');
          
          // Set preview canvas size to match
          previewCanvasRef.current.width = canvas.width;
          previewCanvasRef.current.height = canvas.height;
          
          // Draw the preview
          ctx.drawImage(canvas, 0, 0);
        }
      };

      // Update preview whenever text, canvas size, or font changes
      React.useEffect(() => {
        updatePreview();
      }, [text, canvasSize, font]);

      const printText = async () => {
        if (!characteristic || !text.trim()) {
          setStatus('Nothing to print');
          return;
        }

        try {
          // Check connection
          if (!device || !device.gatt.connected) {
            setStatus('Printer disconnected. Please reconnect.');
            setIsConnected(false);
            return;
          }

          setStatus('Converting to bitmap...');

          // Convert text to bitmap using selected canvas size and font
          const canvas = textToBitmap(text, canvasSize, font);
          const printData = getPrintData(canvas);
          
          const widthBytes = canvas.width / 8;
          const heightBytes = canvas.height;
          
          const heatTime = DARKNESS_LEVELS[darkness].value;
          
          setStatus('Sending initialization...');
          
          // Send heat settings for darkness control
          await characteristic.writeValueWithResponse(getHeatSettings(heatTime));
          await new Promise(resolve => setTimeout(resolve, 30));
          
          // Send header
          await characteristic.writeValueWithResponse(
            getHeaderData(widthBytes, heightBytes)
          );
          
          setStatus('Printing...');
          
          // Send data in chunks
          for (let i = 0; i < printData.length; i += PACKET_SIZE_BYTES) {
            const chunk = printData.slice(i, Math.min(i + PACKET_SIZE_BYTES, printData.length));
            await characteristic.writeValueWithResponse(chunk);
            
            // Update progress
            const progress = Math.round((i / printData.length) * 100);
            setStatus(`Printing... ${progress}%`);
          }
          
          setStatus('Finishing...');
          
          // Send end data
          await characteristic.writeValueWithResponse(END_DATA);
          
          setStatus('Printed successfully!');
          
          setTimeout(() => {
            if (isConnected && device) {
              setStatus('Connected to ' + device.name);
            }
          }, 2000);

        } catch (error) {
          console.error('Print failed:', error);
          setStatus('Print failed: ' + error.message);
          
          // Check if we lost connection
          if (!device || !device.gatt.connected) {
            setIsConnected(false);
            setStatus('Connection lost. Please reconnect.');
          }
        }
      };

      const clearText = () => {
        setText('');
        textareaRef.current?.focus();
      };

      return (
        <div className="thermal-writer">
          <style>{`
            @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap');
            
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }

            body {
              margin: 0;
              padding: 0;
            }

            .thermal-writer {
              min-height: 100vh;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              padding: 2rem;
              font-family: 'JetBrains Mono', monospace;
              display: flex;
              align-items: center;
              justify-content: center;
            }

            .container {
              max-width: 600px;
              width: 100%;
              background: #f8f5f0;
              border-radius: 16px;
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
              overflow: hidden;
              position: relative;
            }

            .container::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              height: 8px;
              background: repeating-linear-gradient(
                90deg,
                #000 0px,
                #000 2px,
                transparent 2px,
                transparent 4px
              );
            }

            .header {
              background: #2d2d2d;
              color: #00ff00;
              padding: 1.5rem;
              border-bottom: 3px solid #000;
            }

            .header h1 {
              font-size: 1.5rem;
              font-weight: 700;
              margin-bottom: 0.5rem;
              text-transform: uppercase;
              letter-spacing: 2px;
              text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            }

            .status-bar {
              display: flex;
              align-items: center;
              gap: 0.5rem;
              font-size: 0.85rem;
              margin-top: 0.5rem;
            }

            .status-indicator {
              width: 10px;
              height: 10px;
              border-radius: 50%;
              background: ${isConnected ? '#00ff00' : '#ff3333'};
              box-shadow: 0 0 10px ${isConnected ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 51, 51, 0.6)'};
              animation: ${isConnected ? 'pulse 2s ease-in-out infinite' : 'none'};
            }

            @keyframes pulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.5; }
            }

            .controls {
              padding: 1.5rem;
              background: #e8e5e0;
              border-bottom: 2px dashed #999;
              display: flex;
              gap: 1rem;
              flex-wrap: wrap;
              align-items: center;
            }

            .control-group {
              display: flex;
              flex-direction: column;
              gap: 0.5rem;
            }

            .control-label {
              font-size: 0.75rem;
              font-weight: 700;
              text-transform: uppercase;
              letter-spacing: 0.5px;
              color: #000;
            }

            select {
              padding: 0.5rem 1rem;
              border: 2px solid #000;
              background: #fff;
              font-family: 'JetBrains Mono', monospace;
              font-size: 0.85rem;
              font-weight: 700;
              cursor: pointer;
              text-transform: uppercase;
              box-shadow: 2px 2px 0 #000;
            }

            select:focus {
              outline: none;
              border-color: #667eea;
            }

            .btn {
              padding: 0.75rem 1.5rem;
              border: 2px solid #000;
              background: #fff;
              color: #000;
              font-family: 'JetBrains Mono', monospace;
              font-size: 0.9rem;
              font-weight: 700;
              cursor: pointer;
              transition: all 0.2s;
              text-transform: uppercase;
              letter-spacing: 1px;
              box-shadow: 4px 4px 0 #000;
              position: relative;
            }

            .btn:hover {
              transform: translate(2px, 2px);
              box-shadow: 2px 2px 0 #000;
            }

            .btn:active {
              transform: translate(4px, 4px);
              box-shadow: 0 0 0 #000;
            }

            .btn-primary {
              background: #00ff00;
              border-color: #000;
            }

            .btn-danger {
              background: #ff3333;
              color: #fff;
            }

            .btn-secondary {
              background: #ffd700;
            }

            .btn:disabled {
              opacity: 0.5;
              cursor: not-allowed;
              transform: none;
              box-shadow: 2px 2px 0 #000;
            }

            .editor {
              padding: 2rem;
              background: #f8f5f0;
              display: grid;
              grid-template-columns: 1fr 1fr;
              gap: 2rem;
            }

            @media (max-width: 768px) {
              .editor {
                grid-template-columns: 1fr;
              }
            }

            .editor-column {
              display: flex;
              flex-direction: column;
              gap: 1rem;
            }

            .preview-section {
              display: flex;
              flex-direction: column;
              align-items: flex-start;
              gap: 1rem;
            }

            .preview-label {
              font-size: 0.85rem;
              font-weight: 700;
              text-transform: uppercase;
              letter-spacing: 1px;
              color: #000;
            }

            .preview-canvas-wrapper {
              border: 3px solid #000;
              box-shadow: 4px 4px 0 #000;
              background: #fff;
              padding: 0.5rem;
              max-width: 100%;
              overflow: auto;
              align-self: center;
            }

            #previewCanvas {
              display: block;
              image-rendering: pixelated;
              max-width: 100%;
              height: auto;
            }

            .char-count {
              font-size: 0.75rem;
              color: #666;
              margin-bottom: 1rem;
              font-family: 'Space Mono', monospace;
            }

            textarea {
              width: 100%;
              min-height: 400px;
              flex: 1;
              padding: 1rem;
              border: 2px solid #000;
              background: rgba(255, 255, 255, 0.8);
              font-family: 'Space Mono', monospace;
              font-size: 1rem;
              line-height: 1.5rem;
              resize: vertical;
              color: #000;
              box-shadow: inset 2px 2px 8px rgba(0, 0, 0, 0.1);
            }

            textarea:focus {
              outline: none;
              border-color: #667eea;
              background: rgba(255, 255, 255, 0.95);
            }

            textarea::placeholder {
              color: #999;
              font-style: italic;
            }

            .footer {
              padding: 1rem 1.5rem;
              background: #2d2d2d;
              color: #00ff00;
              font-size: 0.75rem;
              text-align: center;
              font-family: 'Space Mono', monospace;
            }
          `}</style>

          <div className="container">
            <div className="header">
              <h1>‚ö° Thermal Writer</h1>
              <div className="status-bar">
                <div className="status-indicator"></div>
                <span>{status}</span>
              </div>
            </div>

            <div className="controls">
              {!isConnected ? (
                <>
                  <button className="btn btn-primary" onClick={connectToPrinter}>
                    Connect to Printer
                  </button>
                  <div className="control-group">
                    <label className="control-label">Canvas Size</label>
                    <select value={canvasSize} onChange={(e) => setCanvasSize(e.target.value)}>
                      {Object.entries(CANVAS_SIZES).map(([key, {label}]) => (
                        <option key={key} value={key}>{label}</option>
                      ))}
                    </select>
                  </div>
                  <div className="control-group">
                    <label className="control-label">Font</label>
                    <select value={font} onChange={(e) => setFont(e.target.value)}>
                      {Object.entries(FONT_OPTIONS).map(([key, {label}]) => (
                        <option key={key} value={key}>{label}</option>
                      ))}
                    </select>
                  </div>
                  <div className="control-group">
                    <label className="control-label">Darkness</label>
                    <select value={darkness} onChange={(e) => setDarkness(e.target.value)}>
                      {Object.entries(DARKNESS_LEVELS).map(([key, {label}]) => (
                        <option key={key} value={key}>{label}</option>
                      ))}
                    </select>
                  </div>
                </>
              ) : (
                <>
                  <button className="btn btn-danger" onClick={disconnect}>
                    Disconnect
                  </button>
                  <button className="btn btn-primary" onClick={printText} disabled={!text.trim()}>
                    Print
                  </button>
                  <button className="btn btn-secondary" onClick={clearText}>
                    Clear
                  </button>
                  <div className="control-group">
                    <label className="control-label">Canvas Size</label>
                    <select value={canvasSize} onChange={(e) => setCanvasSize(e.target.value)}>
                      {Object.entries(CANVAS_SIZES).map(([key, {label}]) => (
                        <option key={key} value={key}>{label}</option>
                      ))}
                    </select>
                  </div>
                  <div className="control-group">
                    <label className="control-label">Font</label>
                    <select value={font} onChange={(e) => setFont(e.target.value)}>
                      {Object.entries(FONT_OPTIONS).map(([key, {label}]) => (
                        <option key={key} value={key}>{label}</option>
                      ))}
                    </select>
                  </div>
                  <div className="control-group">
                    <label className="control-label">Darkness</label>
                    <select value={darkness} onChange={(e) => setDarkness(e.target.value)}>
                      {Object.entries(DARKNESS_LEVELS).map(([key, {label}]) => (
                        <option key={key} value={key}>{label}</option>
                      ))}
                    </select>
                  </div>
                </>
              )}
            </div>

            <div className="editor">
              <div className="editor-column">
                <div className="preview-section">
                  <span className="preview-label">üìÑ Live Preview</span>
                  <div className="preview-canvas-wrapper">
                    <canvas ref={previewCanvasRef} id="previewCanvas"></canvas>
                  </div>
                  <div className="char-count">
                    {text.length} characters ‚Ä¢ {text.split('\n').length} lines
                    <br/>
                    <span style={{fontSize: '0.7rem', color: '#999'}}>
                      Canvas: {CANVAS_SIZES[canvasSize].label} ‚Ä¢ ~33 chars/line
                    </span>
                  </div>
                </div>
              </div>
              
              <div className="editor-column">
                <span className="preview-label">‚úèÔ∏è Text Editor</span>
                <textarea
                  ref={textareaRef}
                  value={text}
                  onChange={(e) => setText(e.target.value)}
                  placeholder="Start typing your thermal masterpiece..."
                  spellCheck="false"
                />
              </div>
            </div>

            <div className="footer">
              PHOMEMO M02S ‚Ä¢ WEB BLUETOOTH ‚Ä¢ THERMAL PRINTING
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ThermalWriter />);
  </script>
</body>
</html>
