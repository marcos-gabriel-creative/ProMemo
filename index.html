<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>V2 Thermal Writer - Phomemo M02S</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef } = React;

    function ThermalWriter() {
      const [isConnected, setIsConnected] = useState(false);
      const [text, setText] = useState('');
      const [status, setStatus] = useState('Disconnected');
      const [device, setDevice] = useState(null);
      const [characteristic, setCharacteristic] = useState(null);
      const textareaRef = useRef(null);

      const connectToPrinter = async () => {
        try {
          setStatus('Connecting...');
          
          // Request Bluetooth device with the correct service UUID
          const device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: 'M02' }],
            optionalServices: ['0000ff00-0000-1000-8000-00805f9b34fb']
          });

          setDevice(device);
          
          // Add disconnect handler
          device.addEventListener('gattserverdisconnected', () => {
            console.log('Device disconnected');
            setIsConnected(false);
            setStatus('Printer disconnected');
            setCharacteristic(null);
          });

          setStatus('Connecting to GATT server...');
          const server = await device.gatt.connect();
          
          setStatus('Getting service...');
          const service = await server.getPrimaryService('0000ff00-0000-1000-8000-00805f9b34fb');
          
          setStatus('Getting characteristic...');
          const char = await service.getCharacteristic('0000ff02-0000-1000-8000-00805f9b34fb');

          setCharacteristic(char);
          setIsConnected(true);
          setStatus('Connected to ' + device.name);
          
        } catch (error) {
          console.error('Connection failed:', error);
          setStatus('Connection failed: ' + error.message);
          setIsConnected(false);
        }
      };

      const disconnect = () => {
        if (device && device.gatt.connected) {
          device.gatt.disconnect();
        }
        setDevice(null);
        setCharacteristic(null);
        setIsConnected(false);
        setStatus('Disconnected');
      };

      // Packet size for Bluetooth transmission
      const PACKET_SIZE_BYTES = 128;

      // Header data for print session
      const getHeaderData = (widthBytes, heightBytes) => {
        return new Uint8Array([
          0x1b, 0x40,           // ESC @ - initialize printer
          0x1d, 0x76, 0x30, 0x00, // GS v 0 - raster bit image
          widthBytes & 0xFF, (widthBytes >> 8) & 0xFF,     // width in bytes (little-endian)
          heightBytes & 0xFF, (heightBytes >> 8) & 0xFF    // height in bytes (little-endian)
        ]);
      };

      // End data for print session - feed 4 lines for easy tearing
      const END_DATA = new Uint8Array([0x1b, 0x64, 0x04]); // ESC d 4 - print and feed 4 lines

      // Determine if pixel should be printed (1 = black dot, 0 = white/no print)
      const getWhitePixel = (canvas, imageData, x, y) => {
        const idx = (canvas.width * y + x) * 4;
        const red = imageData[idx];
        const green = imageData[idx + 1];
        const blue = imageData[idx + 2];
        // Return 1 for black pixels (print), 0 for white pixels (don't print)
        return red + green + blue > 384 ? 0 : 1;
      };

      // Convert canvas to print data
      const getPrintData = (canvas) => {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        
        // Each 8 pixels in a row is represented by a byte
        const data = new Uint8Array((canvas.width / 8) * canvas.height);
        let offset = 0;
        
        // Loop through image rows
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width / 8; x++) {
            const x8 = x * 8;
            // Convert 8 pixels to 1 byte
            data[offset++] =
              getWhitePixel(canvas, imageData, x8 + 0, y) * 128 +
              getWhitePixel(canvas, imageData, x8 + 1, y) * 64 +
              getWhitePixel(canvas, imageData, x8 + 2, y) * 32 +
              getWhitePixel(canvas, imageData, x8 + 3, y) * 16 +
              getWhitePixel(canvas, imageData, x8 + 4, y) * 8 +
              getWhitePixel(canvas, imageData, x8 + 5, y) * 4 +
              getWhitePixel(canvas, imageData, x8 + 6, y) * 2 +
              getWhitePixel(canvas, imageData, x8 + 7, y);
          }
        }
        
        return data;
      };

      const textToBitmap = (text) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // M02S specs: 384 pixels wide (48mm at 8 pixels/mm = 203 DPI)
        const width = 384;
        const fontSize = 18; // Reduced from 24 to fit more characters
        const lineHeight = 24; // Reduced from 32
        
        // Calculate required height
        const lines = text.split('\n');
        const height = Math.max(lineHeight * lines.length + 20, 100);
        
        canvas.width = width;
        canvas.height = height;
        
        // White background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
        
        // Black text
        ctx.fillStyle = 'black';
        ctx.font = `${fontSize}px "Space Mono", monospace`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        // Draw each line with less left padding
        lines.forEach((line, i) => {
          ctx.fillText(line, 5, i * lineHeight + 8); // Reduced padding from 10 to 5
        });
        
        return canvas;
      };

      const printText = async () => {
        if (!characteristic || !text.trim()) {
          setStatus('Nothing to print');
          return;
        }

        try {
          // Check connection
          if (!device || !device.gatt.connected) {
            setStatus('Printer disconnected. Please reconnect.');
            setIsConnected(false);
            return;
          }

          setStatus('Converting to bitmap...');

          // Convert text to bitmap
          const canvas = textToBitmap(text);
          const printData = getPrintData(canvas);
          
          const widthBytes = canvas.width / 8;
          const heightBytes = canvas.height;
          
          setStatus('Sending header...');
          
          // Send header
          await characteristic.writeValueWithResponse(
            getHeaderData(widthBytes, heightBytes)
          );
          
          setStatus('Printing...');
          
          // Send data in chunks
          for (let i = 0; i < printData.length; i += PACKET_SIZE_BYTES) {
            const chunk = printData.slice(i, Math.min(i + PACKET_SIZE_BYTES, printData.length));
            await characteristic.writeValueWithResponse(chunk);
            
            // Update progress
            const progress = Math.round((i / printData.length) * 100);
            setStatus(`Printing... ${progress}%`);
          }
          
          setStatus('Finishing...');
          
          // Send end data
          await characteristic.writeValueWithResponse(END_DATA);
          
          setStatus('Printed successfully!');
          
          setTimeout(() => {
            if (isConnected && device) {
              setStatus('Connected to ' + device.name);
            }
          }, 2000);

        } catch (error) {
          console.error('Print failed:', error);
          setStatus('Print failed: ' + error.message);
          
          // Check if we lost connection
          if (!device || !device.gatt.connected) {
            setIsConnected(false);
            setStatus('Connection lost. Please reconnect.');
          }
        }
      };

      const clearText = () => {
        setText('');
        textareaRef.current?.focus();
      };

      return (
        <div className="thermal-writer">
          <style>{`
            @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Space+Mono:wght@400;700&display=swap');
            
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }

            body {
              margin: 0;
              padding: 0;
            }

            .thermal-writer {
              min-height: 100vh;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              padding: 2rem;
              font-family: 'JetBrains Mono', monospace;
              display: flex;
              align-items: center;
              justify-content: center;
            }

            .container {
              max-width: 600px;
              width: 100%;
              background: #f8f5f0;
              border-radius: 16px;
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
              overflow: hidden;
              position: relative;
            }

            .container::before {
              content: '';
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              height: 8px;
              background: repeating-linear-gradient(
                90deg,
                #000 0px,
                #000 2px,
                transparent 2px,
                transparent 4px
              );
            }

            .header {
              background: #2d2d2d;
              color: #00ff00;
              padding: 1.5rem;
              border-bottom: 3px solid #000;
            }

            .header h1 {
              font-size: 1.5rem;
              font-weight: 700;
              margin-bottom: 0.5rem;
              text-transform: uppercase;
              letter-spacing: 2px;
              text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            }

            .status-bar {
              display: flex;
              align-items: center;
              gap: 0.5rem;
              font-size: 0.85rem;
              margin-top: 0.5rem;
            }

            .status-indicator {
              width: 10px;
              height: 10px;
              border-radius: 50%;
              background: ${isConnected ? '#00ff00' : '#ff3333'};
              box-shadow: 0 0 10px ${isConnected ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 51, 51, 0.6)'};
              animation: ${isConnected ? 'pulse 2s ease-in-out infinite' : 'none'};
            }

            @keyframes pulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.5; }
            }

            .controls {
              padding: 1.5rem;
              background: #e8e5e0;
              border-bottom: 2px dashed #999;
              display: flex;
              gap: 1rem;
              flex-wrap: wrap;
            }

            .btn {
              padding: 0.75rem 1.5rem;
              border: 2px solid #000;
              background: #fff;
              color: #000;
              font-family: 'JetBrains Mono', monospace;
              font-size: 0.9rem;
              font-weight: 700;
              cursor: pointer;
              transition: all 0.2s;
              text-transform: uppercase;
              letter-spacing: 1px;
              box-shadow: 4px 4px 0 #000;
              position: relative;
            }

            .btn:hover {
              transform: translate(2px, 2px);
              box-shadow: 2px 2px 0 #000;
            }

            .btn:active {
              transform: translate(4px, 4px);
              box-shadow: 0 0 0 #000;
            }

            .btn-primary {
              background: #00ff00;
              border-color: #000;
            }

            .btn-danger {
              background: #ff3333;
              color: #fff;
            }

            .btn-secondary {
              background: #ffd700;
            }

            .btn:disabled {
              opacity: 0.5;
              cursor: not-allowed;
              transform: none;
              box-shadow: 2px 2px 0 #000;
            }

            .editor {
              padding: 2rem;
              background: #f8f5f0;
              background-image: 
                repeating-linear-gradient(
                  transparent,
                  transparent 1.5rem,
                  #d8d5d0 1.5rem,
                  #d8d5d0 calc(1.5rem + 1px)
                );
            }

            .char-count {
              font-size: 0.75rem;
              color: #666;
              margin-bottom: 1rem;
              font-family: 'Space Mono', monospace;
            }

            textarea {
              width: 100%;
              min-height: 400px;
              padding: 1rem;
              border: 2px solid #000;
              background: rgba(255, 255, 255, 0.8);
              font-family: 'Space Mono', monospace;
              font-size: 1rem;
              line-height: 1.5rem;
              resize: vertical;
              color: #000;
              box-shadow: inset 2px 2px 8px rgba(0, 0, 0, 0.1);
            }

            textarea:focus {
              outline: none;
              border-color: #667eea;
              background: rgba(255, 255, 255, 0.95);
            }

            textarea::placeholder {
              color: #999;
              font-style: italic;
            }

            .footer {
              padding: 1rem 1.5rem;
              background: #2d2d2d;
              color: #00ff00;
              font-size: 0.75rem;
              text-align: center;
              font-family: 'Space Mono', monospace;
            }

            .preview-note {
              background: #fff3cd;
              border: 2px dashed #856404;
              padding: 1rem;
              margin: 1rem 1.5rem;
              border-radius: 4px;
              font-size: 0.85rem;
              color: #856404;
            }
          `}</style>

          <div className="container">
            <div className="header">
              <h1>‚ö° Thermal Writer</h1>
              <div className="status-bar">
                <div className="status-indicator"></div>
                <span>{status}</span>
              </div>
            </div>

            <div className="controls">
              {!isConnected ? (
                <button className="btn btn-primary" onClick={connectToPrinter}>
                  Connect to Printer
                </button>
              ) : (
                <>
                  <button className="btn btn-danger" onClick={disconnect}>
                    Disconnect
                  </button>
                  <button className="btn btn-primary" onClick={printText} disabled={!text.trim()}>
                    Print
                  </button>
                  <button className="btn btn-secondary" onClick={clearText}>
                    Clear
                  </button>
                </>
              )}
            </div>

            <div className="preview-note">
              <strong>üí° Tip:</strong> Phomemo M02S prints approximately 32 characters per line. 
              Keep your lines concise for best results!
              <br/><br/>
              <strong>üîç Debug Mode:</strong> Open your browser's console (F12) to see discovered Bluetooth services and UUIDs.
            </div>

            <div className="editor">
              <div className="char-count">
                {text.length} characters ‚Ä¢ {text.split('\n').length} lines
              </div>
              <textarea
                ref={textareaRef}
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="Start typing your thermal masterpiece..."
                spellCheck="false"
              />
            </div>

            <div className="footer">
              PHOMEMO M02S ‚Ä¢ WEB BLUETOOTH ‚Ä¢ THERMAL PRINTING
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ThermalWriter />);
  </script>
</body>
</html>
